import { createClient } from '@supabase/supabase-js';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Supabase configuration
const SUPABASE_URL = process.env.VITE_SUPABASE_URL;
const SUPABASE_SERVICE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

if (!SUPABASE_URL || !SUPABASE_SERVICE_KEY) {
  console.error('‚ùå Supabase environment variables are required');
  console.error('Please set VITE_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY');
  process.exit(1);
}

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY);

// Configuration
const SCRAPED_PRODUCTS_FILE = path.join(__dirname, 'scraped-data', 'all_products.json');

// Utility functions
function generateSlug(text) {
  return text
    .toLowerCase()
    .replace(/ƒü/g, 'g')
    .replace(/√º/g, 'u')
    .replace(/≈ü/g, 's')
    .replace(/ƒ±/g, 'i')
    .replace(/√∂/g, 'o')
    .replace(/√ß/g, 'c')
    .replace(/[^a-z0-9\s]+/g, '') // Remove special characters except spaces
    .trim()
    .replace(/\s+/g, '-') // Replace spaces with dashes
    .replace(/-+/g, '-') // Replace multiple dashes with single dash
    .replace(/^-+|-+$/g, ''); // Remove leading/trailing dashes
}

// Smart category mapping based on existing VentHub categories
function mapToExistingCategory(productName, brandName) {
  const name = productName.toLowerCase();
  const brand = brandName.toLowerCase();

  // Ex-proof/ATEX fanlar i√ßin √∂zel kontrol
  if (name.includes('atex') || name.includes('ex-proof') || name.includes('patlama')) {
    return { category: 'End√ºstriyel Fanlar', needsNewCategory: 'ATEX/Ex-Proof Fanlar' };
  }

  // Vortice √ºr√ºnlerini tip bazƒ±nda kategorize et
  if (brand === 'vortice') {
    if (name.includes('lineo') && name.includes('quiet')) return { category: 'Sessiz Fanlar' };
    if (name.includes('lineo')) return { category: 'Kanal Fanlarƒ±' };
    if (name.includes('quadro')) return { category: 'Santrif√ºj Fanlar' };
    if (name.includes('punto') || name.includes('me ')) return { category: 'Aksiyel Fanlar' };
    if (name.includes('air door')) return { category: 'Hava Perdeleri' };
    if (name.includes('hrw') || name.includes('ƒ±sƒ± geri')) return { category: 'Isƒ± Geri Kazanƒ±m Cihazlarƒ±' };
    if (name.includes('deumido') || name.includes('nem')) return { category: 'Nem Alma Cihazlarƒ±' };
    if (name.includes('depuro') || name.includes('temizleyici')) return { category: 'Hava Temizleyiciler' };
    if (name.includes('tiracamino')) return { category: 'Aksiyel Fanlar' };
    if (name.includes('ca ') || name.includes('crc')) return { category: 'Kanal Fanlarƒ±' };
    return { category: 'Fanlar' }; // Default Vortice products
  }

  // Nicotra/Gebhardt √ºr√ºnleri
  if (brand.includes('nicotra') || brand.includes('gebhardt')) {
    if (name.includes('radyal') || name.includes('√ßift emi≈üli')) return { category: 'Santrif√ºj Fanlar' };
    return { category: 'End√ºstriyel Fanlar' };
  }

  // Genel √ºr√ºn kategorileri
  if (name.includes('sessiz') && name.includes('fan')) return { category: 'Sessiz Fanlar' };
  if (name.includes('kanal') && name.includes('fan')) return { category: 'Kanal Fanlarƒ±' };
  if (name.includes('√ßatƒ±') && name.includes('fan')) return { category: '√áatƒ± Fanlarƒ±' };
  if (name.includes('konut') && name.includes('fan')) return { category: 'Aksiyel Fanlar' };
  if (name.includes('duvar') && name.includes('fan')) return { category: 'Duvar Fanlarƒ±' };
  if (name.includes('santrif√ºj') || name.includes('santrifuj')) return { category: 'Santrif√ºj Fanlar' };
  if (name.includes('duman egzoz')) return { category: 'End√ºstriyel Fanlar' };
  if (name.includes('otopark') || name.includes('jet')) return { category: 'Jet Fanlar' };
  if (name.includes('sƒ±ƒüƒ±nak')) return { category: 'End√ºstriyel Fanlar' };
  if (name.includes('plug')) return { category: 'Kanal Fanlarƒ±' };
  
  if (name.includes('hava perdesi')) return { category: 'Hava Perdeleri' };
  if (name.includes('elektrikli ƒ±sƒ±tƒ±cƒ±lƒ±')) return { category: 'Hava Perdeleri' };
  if (name.includes('ortam havalƒ±')) return { category: 'Hava Perdeleri' };
  
  if (name.includes('flexible') || name.includes('kanal')) return { category: 'Flexible Hava Kanallarƒ±' };
  if (name.includes('hƒ±z anahtarƒ±')) return { category: 'Hƒ±z Kontrol√º Cihazlarƒ±' };

  // Default olarak Fanlar kategorisi
  if (name.includes('fan')) return { category: 'Fanlar' };
  
  return { category: 'Aksesuarlar' }; // Diƒüer t√ºm √ºr√ºnler
}

function normalizeBrandName(brandName) {
  const brandMap = {
    'GENEL': 'AVenS',
    'NICOTRA': 'Nicotra Gebhardt', 
    'VORTICE': 'Vortice'
  };
  return brandMap[brandName] || brandName;
}

function cleanProductName(name) {
  return name
    .replace(/^(Vortice|VORTICE)\s+/gi, '')
    .replace(/^(NICOTRA|Nicotra)\s+(GEBHARDT|Gebhardt)\s+/gi, '')
    .replace(/^(AVenS|AVENS)\s+/gi, '')
    .trim();
}

function generateSKU(brand, name, id) {
  const brandPrefix = brand.substring(0, 3).toUpperCase();
  const namePrefix = name.replace(/[^A-Z0-9]/gi, '').substring(0, 5).toUpperCase();
  const idSuffix = id.substring(0, 6).toUpperCase();
  return `${brandPrefix}-${namePrefix}-${idSuffix}`;
}

function isValidProduct(product) {
  return product.name && 
         product.name.trim().length > 0 &&
         !product.name.includes('404') &&
         !product.name.includes('Sepetim') &&
         !product.name.includes('Kataloglar') &&
         !product.name.includes('linkedin.com') &&
         !product.name.includes('instagram.com') &&
         !product.name.includes('argenova.com') &&
         !product.name.toLowerCase().includes('marmara sanayi') &&
         !product.name.toLowerCase().includes('havalandƒ±rma i√ßin en iyi') &&
         !product.name.toLowerCase().includes('dijital d√ºnya');
}

// Database functions
async function getCategoryByName(categoryName) {
  const { data, error } = await supabase
    .from('categories')
    .select('id, name, slug')
    .eq('name', categoryName)
    .single();

  if (error && error.code !== 'PGRST116') {
    throw error;
  }

  return data;
}

async function createNewCategory(categoryName, description = null) {
  const slug = generateSlug(categoryName);
  
  // Check if slug already exists and generate alternative if needed
  const { data: existingSlug } = await supabase
    .from('categories')
    .select('slug')
    .eq('slug', slug)
    .single();
  
  let finalSlug = slug;
  if (existingSlug) {
    // Generate unique slug with timestamp
    finalSlug = `${slug}-${Date.now()}`;
    console.log(`‚ö†Ô∏è Slug √ßakƒ±≈ümasƒ±, alternatif kullanƒ±lƒ±yor: ${finalSlug}`);
  }
  
  const { data, error } = await supabase
    .from('categories')
    .insert([{
      name: categoryName,
      slug: finalSlug,
      description: description || `${categoryName} - Avens entegrasyonu ile eklendi`,
      level: 0
    }])
    .select('id, name, slug')
    .single();

  if (error) {
    throw error;
  }

  console.log(`‚ú® Yeni kategori olu≈üturuldu: ${categoryName}`);
  return data;
}

async function importProduct(product, categoryId) {
  const cleanedName = cleanProductName(product.name);
  const slug = generateSlug(cleanedName);
  const brandName = normalizeBrandName(product.brand);
  
  // Check if product already exists by SKU or slug
  const sku = product.product_code || generateSKU(brandName, cleanedName, product.id);
  
  const { data: existing, error: checkError } = await supabase
    .from('products')
    .select('id, name, sku')
    .or(`sku.eq.${sku},slug.eq.${slug}`)
    .single();

  if (checkError && checkError.code !== 'PGRST116') {
    throw checkError;
  }

  if (existing) {
    console.log(`‚ö†Ô∏è √úr√ºn zaten mevcut: ${existing.name} (${existing.sku})`);
    return existing.id;
  }

  // Prepare product data
  const productData = {
    name: cleanedName,
    slug: slug,
    description: `${cleanedName} - Avens distrib√ºt√∂rl√ºƒü√º ile VentHub'da`,
    brand: brandName,
    category_id: categoryId,
    sku: sku,
    price: product.price || 0,
    purchase_price: product.price ? (product.price * 0.75) : 0, // 25% margin
    stock_qty: 0, // Start with 0 stock
    low_stock_threshold: 5,
    status: 'active',
    is_featured: false,
    meta_title: `${cleanedName} - ${brandName} | VentHub`,
    meta_description: `${cleanedName} √ºr√ºn√ºn√º VentHub'dan uygun fiyatlarla satƒ±n alƒ±n. ${brandName} kalitesi ile g√ºvenli alƒ±≈üveri≈ü.`,
    technical_specs: {},
    model_code: product.product_code || null
  };

  // Add image URL if available
  if (product.image_url && !product.image_url.includes('404') && !product.image_url.includes('undefined')) {
    productData.image_url = product.image_url;
  }

  // Create product
  const { data: newProduct, error: createError } = await supabase
    .from('products')
    .insert([productData])
    .select('id, name')
    .single();

  if (createError) {
    throw createError;
  }

  console.log(`‚ú® √úr√ºn olu≈üturuldu: ${newProduct.name} (${brandName})`);

  // Create product image record if we have an image
  if (productData.image_url) {
    const { error: imageError } = await supabase
      .from('product_images')
      .insert([{
        product_id: newProduct.id,
        path: productData.image_url,
        alt: cleanedName,
        sort_order: 1
      }]);

    if (imageError) {
      console.error(`‚ùå √úr√ºn resmi eklenemedi ${newProduct.name}:`, imageError.message);
    } else {
      console.log(`üì∑ Resim eklendi: ${newProduct.name}`);
    }
  }

  return newProduct.id;
}

async function main() {
  console.log('üöÄ Avens √ºr√ºnlerini VentHub\'a akƒ±llƒ± import ba≈ülƒ±yor...');

  try {
    // Load products data
    console.log('üìñ √úr√ºn verilerini y√ºkl√ºyorum...');
    const productsData = JSON.parse(await fs.readFile(SCRAPED_PRODUCTS_FILE, 'utf-8'));
    
    // Filter valid products
    const validProducts = productsData.filter(isValidProduct);
    console.log(`‚úÖ ƒ∞mport edilecek ge√ßerli √ºr√ºn: ${validProducts.length}`);

    // Analyze category mapping
    const categoryAnalysis = {};
    const needsNewCategory = new Set();

    validProducts.forEach(product => {
      const brandName = normalizeBrandName(product.brand);
      const mapping = mapToExistingCategory(product.name, brandName);
      
      if (!categoryAnalysis[mapping.category]) {
        categoryAnalysis[mapping.category] = [];
      }
      categoryAnalysis[mapping.category].push(product);

      if (mapping.needsNewCategory) {
        needsNewCategory.add(mapping.needsNewCategory);
      }
    });

    console.log('\nüìä Kategori daƒüƒ±lƒ±mƒ±:');
    Object.entries(categoryAnalysis).forEach(([category, products]) => {
      console.log(`  ${category}: ${products.length} √ºr√ºn`);
    });

    if (needsNewCategory.size > 0) {
      console.log(`\nüÜï Olu≈üturulacak yeni kategoriler: ${[...needsNewCategory].join(', ')}`);
    }

    // Process each category
    const results = {
      success: 0,
      failed: 0,
      newCategories: 0,
      existingCategories: 0
    };

    const categoryCache = new Map();

    for (const [categoryName, products] of Object.entries(categoryAnalysis)) {
      console.log(`\nüìÇ ${categoryName} kategorisi i≈üleniyor...`);

      let categoryData = await getCategoryByName(categoryName);
      
      if (!categoryData) {
        // Kategori mevcut deƒüil, yeni olu≈ütur
        categoryData = await createNewCategory(categoryName);
        results.newCategories++;
      } else {
        console.log(`‚úÖ Mevcut kategori kullanƒ±lƒ±yor: ${categoryData.name}`);
        results.existingCategories++;
      }

      categoryCache.set(categoryName, categoryData);

      // Import products for this category
      for (const product of products) {
        try {
          await importProduct(product, categoryData.id);
          results.success++;
        } catch (error) {
          console.error(`‚ùå √úr√ºn import hatasƒ± ${product.name}:`, error.message);
          results.failed++;
        }
      }
    }

    // Create ATEX category if needed
    if (needsNewCategory.has('ATEX/Ex-Proof Fanlar')) {
      console.log('\nüÜï ATEX/Ex-Proof Fanlar kategorisi olu≈üturuluyor...');
      const endCategoryData = categoryCache.get('End√ºstriyel Fanlar');
      if (endCategoryData) {
        await createNewCategory('ATEX/Ex-Proof Fanlar', 'Patlamaya dayanƒ±klƒ± ATEX sertifikalƒ± fanlar');
      }
    }

    // Summary
    console.log('\nüìä Import √ñzeti:');
    console.log(`‚úÖ Ba≈üarƒ±lƒ±: ${results.success}`);
    console.log(`‚ùå Hatalƒ±: ${results.failed}`);
    console.log(`üÜï Yeni kategori: ${results.newCategories}`);
    console.log(`üìÇ Mevcut kategori kullanƒ±ldƒ±: ${results.existingCategories}`);
    console.log(`üì¶ Toplam √ºr√ºn: ${validProducts.length}`);

    // Brand summary
    const brandCounts = {};
    validProducts.forEach(product => {
      const brand = normalizeBrandName(product.brand);
      brandCounts[brand] = (brandCounts[brand] || 0) + 1;
    });

    console.log('\nüè∑Ô∏è Marka daƒüƒ±lƒ±mƒ±:');
    Object.entries(brandCounts).forEach(([brand, count]) => {
      console.log(`  ${brand}: ${count} √ºr√ºn`);
    });

    console.log('\nüéâ ƒ∞mport ba≈üarƒ±yla tamamlandƒ±!');
    console.log('üí° √ñneriler:');
    console.log('  ‚Ä¢ √úr√ºn fiyatlarƒ±nƒ± admin panelinden g√ºncelleyin');
    console.log('  ‚Ä¢ Stok miktarlarƒ±nƒ± ayarlayƒ±n');
    console.log('  ‚Ä¢ √úr√ºn a√ßƒ±klamalarƒ±nƒ± g√∂zden ge√ßirin');

  } catch (error) {
    console.error('üí• Import hatasƒ±:', error.message);
    process.exit(1);
  }
}

// Run the import
main().catch(console.error);